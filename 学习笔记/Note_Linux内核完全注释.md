#### Linux内核系统体系结构

##### 01 概述

> Linux 内核主要由 5 个模块构成：**进程调度模块**、**内存管理模块**、**文件系统模块**、**进程间通信模块**和**网络接口模块**。

![](imgs\内核结构.png)

1.进程调度模块用来负责控制进程对 CPU 资源的使用。

2.内存管理模块用于确保所有进程能够安全地共享机器主内存区，同时，内存管理模块还支持虚拟内存管理方式，使得Linux 支持进程使用比实际内存空间更多的内存容量。

3.文件系统模块用于支持对外部设备的驱动和存储。

4.进程间通信模块子系统用于支持多种进程间的信息交换方式。

5.网络接口模块提供对多种网络通信标准的访问并支持许多网络硬件。

##### 02 进程调度

> Linux 0.11采用**基于优先级排队的调度策略**。

内核中的**调度程序**用于选择系统中下一个要运行的进程。

调度程序可以看作是为所有处于运行状态的进程分配CPU运行时间的管理代码。

Linux内核任务是非抢占式的，用户进程是抢占式的，被抢占的进程仍然处于TASK_RUNNING状态，只是暂时没有被CPU运行。

------

**schedule（）函数**首先扫描任务数组。通过比较每个就绪态（TASK_RUNNING）任务的CPU时间片counter，选择counter值最大的进程运行。counter（递减值）值越大，就表示CPU运行时间越少。

如果此时所有就绪态（TASK_RUNNING）任务的CPU时间片counter都用完，系统就会根据每个进程的优先权值priority，对进程中所有进程（包括正在睡眠的进程）重新计算每个进程需要CPU运行的时间片值counter，计算公式：

<img src="imgs\counter.jpg" style="zoom: 80%;" />

这样对于正在睡眠的进程被唤醒时就可以获得较高的时间片counter值。然后schedule（）函数重新扫描任务数组中所有处于就绪态的进程，选择一个进程运行。

##### 03 虚拟内存

> 虚拟内存空间的含义是指一种利用二级或外部存储空间，使程序能不受实际物理内存空间限制而使用内存的一种方法。通常虚拟内存空间要比实际物理内存量大得多。

![](imgs\虚拟地址空间分配图.png)

> 三个地址空间：进程的虚拟地址（逻辑地址），CPU的线性地址，内存的物理地址。
>
> 虚拟地址(逻辑地址)空间可包含最多 16K 的段，而每个段最长可达4GB，使得虚拟地址空间容量达到 64TB。线性地址空间和物理地址空间都是 4GB。实际上，如果禁用分页机制，那么线性地址空间就是物理地址空间。

>
> 虚拟地址到物理地址的映射过程：第一阶段使用**分段机制**把程序的逻辑地址变换成处理器可寻址内存空间(称为线性地址空间)中的地址。第二阶段使用**分页机制**把线性地址转换为物理地址。

![](imgs\地址映射.png)



在 Linux 0.11 内核中，为了有效地使用机器中的物理内存，在系统初始化阶段内存被划分成几个功能区域:

![](imgs\物理内存.png)

###### 3.1 内存分段机制

![](imgs\内存地址映射.png)

当程序引用一个内存地址时，通过把相应的段基址加到程序员看得见的逻辑地址上就形成了一个对应的线性地址。此时若没有启用分页机制，则该线性地址就被送到 CPU 的外部地址总线上，用于直接寻址对应的物理内存。

> 把逻辑地址转换成一个线性地址，处理器会执行以下操作:

1. 使用段选择符中的偏移值(段索引)在GDT或LDT表中定位相应的段描述符。(仅当一个新的段选择符加载到段寄存器中时才需要这一步。
2. 利用段描述符检验段的访问权限和范围，以确保该段是可访问的并且偏移量位于段界限内。
3. 段描述符中取得的段基地址加到偏移量上，最后形成一个线性地址。

![](imgs\逻辑地址.png)

[^段选择符:]: 逻辑地址中的段选择符记录了段的属性。段选择符有三个字符段：请求特权级RPL、表指示标志TI和索引值。
[^段描述符]: 段描述符记录了段的基址。

![](imgs\段选择符.png)

###### 3.2 内存分页机制

逻辑地址48位，线性地址32位。一个段4G，一个页面4K，一个段中有2^20个页面。

![](imgs\线性地址.png)

分页转换功能由驻留在内存中的表来描述，该表称为页表(page table)，存放在物理地址空间中。

> 二级表机制

二级表结构允许页表被分散在内存各个页面中，而不需要保存在连续的4MB 内存块中。

一级表是页目录，目录项记录了（存放页表项的）页表的基地址，属性部分记录了页表项（对应一个页表）是否载入内存。

二级表是页表，每个页表项大小为 32 位。由于只需要其中的 20 位来存放页面的物理页面的基地址，因此剩下的 12位表示页内偏移量。

> 缺页

页目录中目录项的存在位的作用：

如果存在位表明对应的二级表不存在，那么处理器就会产生一个异常来通知操作系统。页目录表项中的存在属性使得操作系统可以根据实际使用的线性地址范围来分配二级页表页面。

目录表项中的存在位还可以用于在虚拟内存中存放二级页表（页表项对应的页面）。这意味着在任何时候只有部分二级页表需要存放在物理内存中，而其余的可保存在磁盘上。

处于物理内存中页表对应的页目录项将被标注为存在，以表明可用它们进行分页转换。处于磁盘上的页表对应的页目录项将被标注为不存在。由于二级页表不存在而引发的异常会通知操作系统把缺少的页表从磁盘上加载进物理内存。把页表存储在虚拟内存中减少了保存分页转换表所需要的物理内存量。                     

##### 04 中断机制

> 中断源

中断发生在程序执行的随机时刻，以响应硬件的事件请求或软件产生的信号。

1. 外部中断/硬中断；

2. 软件产生的中断。

外部中断通过处理器芯片上两个引脚(INTR 和NMI)接收。当引脚INTR 接收到外部发生的中断信号时，处理器就会从系统总线上读取外部**中段控制器**(例如8259A)提供的中断向量号。当引脚NMI接收到信号时，就产生一个非屏蔽中断。它使用固定的中断向量号2。

任何通过处理器NTR脚收的外部中断都被称为可屏蔽硬件中断，包括中断向量号 0 到 255。标志寄存器 EFLAGS 中的 IF 标志可用来屏蔽所有这些硬件中断。

> 中断号、中断向量表、中断函数

1.中断号:
中断号唯一标识一个中断请求源。
2.中断向量表:
中断向量表存放着各个中断对应的服务程序入口地址，它是一个数组，数组下标为中断号，元素为中断服务函数的起始地址。
3.中断服务函数:
当中断请求产生时，CPU根据中断号从中断向量表读取中断服务函数的入口地址并跳转执行。中断服务函数内处理具体的中断业务逻辑。

> 中断处理过程

1. 保护当前进程上下文。
2. CPU从中断向量表根据中断号读取中断服务函数地址。
3. CPU跳转执行中断服务函数,在函数内处理中断请求。
4. 执行完中断服务函数后CPU返回执行被中断前的程序。

##### 05 系统调用

![](imgs\系统调用.png)

> 内核源代码在include/unistd.h 文件(133-183 行)中定义了宏函数syscalln()，其中n代表携带的参数个数，可以分别0至3。

若我们在用户程序中直接执行对应的系统调用，那么该系统调用的宏的形式为:

```c
#define _LIBRARY_
#include <unistdh>

/*
int read(int fd, char *buf, int n); 
*/

syscall3(int, read, int, fd, char *, buf, int, n)
```

[^unframebuffer I/O]: 不带缓冲指的是每个read和write都调运内核中的一个系统调运（并不是说此处的read和write是系统调用）。

