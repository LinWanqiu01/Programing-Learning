> `wanqiu`:nail_care:
>
> **指针**
>
> **定义指针变量时必须带  `*`，给指针变量赋值时不能带`*`，通过指针变量修改指针所指向的内存上的数据时要带`*`。**
>
> `float*`和`char*`，float和char，它们是完全不同的数据类型。
>
> 最大的区别是`->`前面放的是指针，而`.`前面跟的是结构体（类）变量。
> 
##### 指针&字符串

> **在 C 语言中，字符串有两种存储方式，一种是通过字符数组存储，另一种是通过字符指针存储。**

![](/imgs/Linux_VM.png)

​																							一个Linux进程的虚拟内存（《深入理解计算机系统》）

###### 01 字符常量/字符变量

一个用**单引号**括起来的单个字符。

实质（含义）：**是一个整形值。**属于四大基本数据类型（分别是**整型，浮点型，指针，聚合类型**）中的整型（integers）。

> 字符常量：

用单引号括起来的一个字符，如`'a'、'A'、'1'、'='`；

只能用单引号括起来，不能用双引号或其他符号。

> 字符变量：

字符变量的类型说明符为char，字符变量定义格式为：char a;、char a,b;

字符变量用来存储字符常量，字符值是以ASCII码的二进制形式存放在变量的内存单元之中的，如字符'x'的ASCII码是120，定义字符变量char a = 'x';，实际上字符变量a内存放120的二进制代码。若将整型值直接赋值给字符变量，如char a = 100;，实际上是将ASCII码为100的字符'd'赋值给了字符变量a；

字符型可看做一种特别短的整型
类型说明符：[signed] char，表示的数值范围：-128 ~ 127，存储大小：1字节
类型说明符：unsigned char，表示的数值范围：0 ~ 255，存储大小：1字节



###### 02 字符串常量/字符串数组

（字符数组）数组方式定义字符串：当数组名用于表达式中时，它们的值也是个**指针常量**。我们可以对它们进行下标引用、间接访问以及指针运算。

```c
//代码1
char str[] = "hello, world";
str[1] = 'a';
```

（字符串指针）指针常量定义字符串：当一个字符串常量出现在表达式中时，它的值是个**指针常量**。编译器把这些指定字符的一份拷贝存储在内存的某个位置（text段：可读，不可写），并存储一个指向第一个字符的指针。（一个是指针的地址，一个是字符串的地址）

指针常量：指针自身的地址不能改变，指针所指向的地址可以改变。

text段：可读不可写。  data段：可读可写。

```c 
//代码2
char *str = "hello, world";
str[1] = 'a';
```

> 两个程序都可以编译，但第二个运行会出现段错误。
>
> 两个程序的区别在：
>
> 第一个程序的 str 属于初始化变量，str 如果是局部变量则指向**栈上的内存区域**，如果是 static 或全局变量则指向进程的 **data 段**内存区域。data 段权限是可读、可写；
>
> 第二个程序中 "hello, world" 是一个**字符串面量**，str 的确指向其地址，但该地址存在于在进程的 **text 段**，text 段除了保存常量还保存可执行代码，因此是**不允许可写权限的，而是只允许可读、可执行权限**。

```c
char p[] = "hello"; // 方式1
 
char *p = "hello"; // 方式2

char *p;
p = (char *)malloc(sizeof(char)*6);
strcpy(p, "hello"); // 方式3
```

下面是错误的：

```c
char *p = NULL;
p = (char *)malloc(sizeof(char)*6);
p = "hello word!";
```

在 `p = "hello word";` 这行代码中，**试图直接将字符串字面量的地址赋值给 `p` 指针**，这是不允许的（字符串指针的值应该是一个字符串常量而不是一个地址）。在 C 语言中，字符串字面量是常量，存储在只读的内存区域，其地址是不可修改的。

可以使用 `strcpy` 函数来实现：`strcpy(p,"hello word");`  `stycpy`是将一块内存的内容复制到另一块内存。



> 比较字符串，stycmp函数：`stycmp(p,"hello word");`   而`if(p == "hello word");`比较的是p指针自身的地址是否等于`hello word`所存放内存的首地址。

> 打印指针的地址：`%p`
>
> ```c
> char *img = "hello";
> printf("img_pointer_addr: %p\n", img);       //打印img指针自身的地址
> printf("img_pointer_cont_addr: %p\n", &img); //打印img指针所存放的地址（所指向的地址）
> ```



> 比较`char* p = NULL;`和`char* p;`
>
> `char* p = NULL;` 是将指针 `p` 初始化为 `NULL`，表示当前指针不指向任何有效的内存地址。
>
> `char* p;` 是一个未初始化的指针变量声明，它不会明确设置指针的初始值。这意味着指针 `p` 的值是不确定的，它可能指向任何内存地址，包括无效的地址。



> wanqiu:nail_care:
>
> **指针**
>
> **定义指针变量时必须带  `*`，给指针变量赋值时不能带`*`，通过指针变量修改指针所指向的内存上的数据时要带`*`。**
>
> `float*`和`char*`，float和char，它们是完全不同的数据类型。
>
> 最大的区别是`->`前面放的是指针，而`.`前面跟的是结构体（类）变量。



[日期](2023.08.03)