#### 类和对象

> 与结构体一样，类只是一种复杂数据类型的声明，**不占用内存空间**。而对象是类这种数据类型的一个变量，或者说是通过类这种数据类型创建出来的一份实实在在的数据，所以占用内存空间。
>
> 类只是一个模板（Template），编译后不占用内存空间，所以在**定义类时不能对成员变量进行初始化**，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了。

##### 使用对象指针

创建的对象在**栈**上分配内存，需要使用`&`获取它的地址：

```c++
Student stu;
Student *pStu = &stu;
```

pStu 是一个指针，它指向 Student 类型的数据，也就是通过 Student 创建出来的对象。

在**堆**上创建对象，需要使用**new**关键字:

```c++
Student *pStu = new Student;
```

> 栈内存是**程序自动管理**的，不能使用 delete 删除在栈上创建的对象；堆内存由**程序员管理**，对象使用完毕后可以通过 delete 删除。在实际开发中，new 和 delete 往往成对出现，以保证及时删除不再使用的对象，防止无用内存堆积。
>
> 使用 new 在堆上创建出来的对象是匿名的（没有对象名），没法直接使用，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。

通过对象名字访问成员使用点号`.`，通过对象指针访问成员使用箭头`->`，这和结构体非常类似。

##### 普通函数和成员函数区别

成员函数是一个类的成员，出现在类体中，它的作用范围由类来决定；而普通函数是独立的，**作用范围是全局的**，或位于某个命名空间内。

##### 类成员的访问权限

> 在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。
>
> 在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员。
>
> 私有的成员变量，不能通过对象直接访问，必须借助public 属性的成员函数来修改它们的值。

##### 封装

将成员变量声明为 private、将部分成员函数声明为 public 的做法体现了类的封装性。所谓封装，是指尽量隐藏类的内部实现，只向用户提供有用的成员函数。

> 在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。
>
> 在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员。

##### 构造函数

名字和类名相同，没有返回值，不需要用户显式调用（用户也不能调用），而是在创建对象时自动执行。

> 构造函数往往用来做一些**初始化工作**，例如对成员变量赋值、预先打开文件等。
>
> 构造函数可以重载。
>
> 如果用户自己没有定义构造函数，那么编译器会自动生成一个默认的构造函数，只是这个构造函数的函数体是空的，也没有形参，也不执行任何操作。

> **析构函数没有参数，不能被重载**，因此一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。

初始化 const 成员变量只有一种方法，就是通过构造函数的初始化列表

##### 析构函数

> 创建对象时系统会自动调用构造函数进行初始化工作，同样，销毁对象时系统也会自动调用一个函数来进行清理工作，例如释放分配的内存、关闭打开的文件等，这个函数就是析构函数。
>
> 注意：析构函数没有参数，不能被重载，因此一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。
>
> 在堆区开辟的内存，在对象销毁要调用析构函数释放这块内存。
>
> ```c
> //构造函数在堆区开辟了一块内存存放数组
> VLA::VLA(int len): m_len(len){  //使用初始化列表来给 m_len 赋值
>     if(len > 0){ m_arr = new int[len];  /*分配内存*/ }
>     else{ m_arr = NULL; }
> }
> //对象销毁后堆区的这块内存并不会释放，所以需要析构函数去手动释放堆区内存
> VLA::~VLA(){
>     delete[] m_arr;  //释放内存
> }
> ```
>
> **析构函数会在对象销毁时系统自动（隐示）调用**，程序员无法显示调用，也不能显示调用。

##### this指针

> this 是 const 指针，它的值是不能被修改的，一切企图修改该指针的操作，如赋值、递增、递减等都是不允许的。
>
> this 只能在成员函数内部使用，用在其他地方没有意义，也是非法的。
>
> 只有当对象被创建后 this 才有意义，因此不能在 static 成员函数中使用。

静态成员函数没有 this指针，不知道指向哪个对象。

编译器在编译一个普通成员函数时，会隐式地增加一个形参 this，并把当前对象的地址赋值给  this，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。

##### 静态成员变量

> 使用静态成员变量来实现**多个对象共享数据**的目标。静态成员变量是一种特殊的成员变量，它被关键字`static`修饰。

static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 成员变量不能使用。

> static 成员变量和普通 static 变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。

static 成员变量**必须在类声明的外部初始化**，具体形式为：

```c++
type class::name = value;
```

##### 静态成员函数

> 普通成员函数可以访问所有成员（包括成员变量和成员函数），静态成员函数只能访问静态成员。

编译器在编译一个普通成员函数时，会隐式地增加一个形参 this，并把当前对象的地址赋值给  this，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。而静态成员函数可以通过类来直接调用，编译器不会为它增加形参  this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。

##### 友元函数

在当前类以外定义的、不属于当前类的函数也可以在类中声明，但要在前面加 friend 关键字，这样就构成了友元函数。友元函数可以是不属于任何类的非成员函数，也可以是其他类的成员函数。

友元函数可以访问当前类中的所有成员，包括 public、protected、private 属性的。

##### 多态和虚函数

> 通过基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数。
>
> 为了让基类指针能够访问派生类的成员函数，C++增加了**虚函数（Virtual Function）**。使用虚函数非常简单，只需要在函数声明前面增加 virtual 关键字。

> 有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为**多态（Polymorphism）**。
>

#### 面向对象进阶

##### 拷贝构造函数

> 当以拷贝的方式初始化一个对象时，会调用一个特殊的构造函数，就是拷贝构造函数。
>
> 拷贝构造函数只有一个参数，它的类型是当前类的引用，而且一般都是 const 引用。

> ###### 1) 为什么必须是当前类的引用呢？
>
> 如果拷贝构造函数的参数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将另外一个对象直接传递给形参，这本身就是一次拷贝，会再次调用拷贝构造函数，然后又将一个对象直接传递给了形参，将继续调用拷贝构造函数……这个过程会一直持续下去，没有尽头，陷入死循环。
>
> 只有当参数是当前类的引用时，才不会导致再次调用拷贝构造函数，这不仅是逻辑上的要求，也是 C++ 语法的要求。
>
> ###### 2) 为什么是 const 引用呢？
>
> 拷贝构造函数的目的是用其它对象的数据来初始化当前对象，并没有期望更改其它对象的数据，添加 const 限制后，这个含义更加明确了。
>
> 另外一个原因是，添加 const 限制后，可以将 const 对象和非 const 对象传递给形参了，因为非 const 类型可以转换为 const 类型。如果没有 const 限制，就不能将 const 对象传递给形参，因为 const 类型不能转换为非 const 类型，这就意味着，不能使用 const 对象来初始化当前对象了。
>
> **3）什么时候调用拷贝构造函数**
>
> 初始化对象时会调用构造函数，不同的初始化方式会调用不同的构造函数：
>
> - 如果用传递进来的实参初始化对象，那么会调用**普通的构造函数**，我们不妨将此称为普通初始化；
> - 如果**用其它对象（现有对象）的数据来初始化对象，那么会调用拷贝构造函数**，这就是以拷贝的方式初始化。

##### 深拷贝

浅拷贝：简单的赋值拷贝操作

深拷贝：在堆区重新申请一块空间进行拷贝操作

如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题

```c++
class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int age ,int height) {
		
		cout << "有参构造函数!" << endl;

		m_age = age;
		m_height = new int(height);
		
	}
	//拷贝构造函数  
	Person(const Person& p) {
		cout << "拷贝构造函数!" << endl;
		//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题
		m_age = p.m_age;
		m_height = new int(*p.m_height);
		
	}

	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
		if (m_height != NULL)
		{
			delete m_height;
		}
	}
public:
	int m_age;
	int* m_height;
};

void test01()
{
	Person p1(18, 180);

	Person p2(p1);

	cout << "p1的年龄： " << p1.m_age << " 身高： " << *p1.m_height << endl;

	cout << "p2的年龄： " << p2.m_age << " 身高： " << *p2.m_height << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

