#### 类和对象

> 与结构体一样，类只是一种复杂数据类型的声明，**不占用内存空间**。而对象是类这种数据类型的一个变量，或者说是通过类这种数据类型创建出来的一份实实在在的数据，所以占用内存空间。
>
> 类只是一个模板（Template），编译后不占用内存空间，所以在**定义类时不能对成员变量进行初始化**，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了。

##### 使用对象指针

在栈上创建对象可以写作`Student stu()`或`Student stu`，在堆上创建对象可以写作

`Student *pstu = new Student()`或`Student *pstu = new Student`，它们都会调用构造函数 `Student()`。

创建的对象在**栈**上分配内存，需要使用`&`获取它的地址：

```c++
Student stu;
Student *pStu = &stu;
```

pStu 是一个指针，它指向 Student 类型的数据，也就是通过 Student 创建出来的对象。

在**堆**上创建对象，需要使用**new**关键字:

```c++
Student *pStu = new Student;
```

> 栈内存是**程序自动管理**的，不能使用 delete 删除在栈上创建的对象；堆内存由**程序员管理**，对象使用完毕后可以通过 delete 删除。在实际开发中，new 和 delete 往往成对出现，以保证及时删除不再使用的对象，防止无用内存堆积。
>
> 使用 new 在堆上创建出来的对象是匿名的（没有对象名），没法直接使用，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。

通过对象名字访问成员使用点号`.`，通过对象指针访问成员使用箭头`->`，这和结构体非常类似。

> **指针**
>
> 定义指针变量时必须带  `*`，给指针变量赋值时不能带`*`，通过指针变量修改指针所指向的内存上的数据时要带`*`。
>
> `float*`和`char*`，float和char，它们是完全不同的数据类型。
>
> 最大的区别是`->`前面放的是指针，而`.`前面跟的是结构体（类）变量。

##### 普通函数和成员函数区别

成员函数是一个类的成员，出现在类体中，它的作用范围由类来决定；而普通函数是独立的，**作用范围是全局的**，或位于某个命名空间内。

##### 类成员的访问权限

> 在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。
>
> 在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员。
>
> 私有的成员变量，不能通过对象直接访问，必须借助public 属性的成员函数来修改它们的值。

##### 封装

将成员变量声明为 private、将部分成员函数声明为 public 的做法体现了类的封装性。所谓封装，是指尽量隐藏类的内部实现，只向用户提供有用的成员函数。

> 在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。
>
> 在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员。

##### 对象的内存模型

类是创建对象的模板，不占用内存空间，不存在于编译后的可执行文件中；而对象是实实在在的数据，需要内存来存储。对象被创建时会在栈区或者堆区分配内存。

> **编译器会将成员变量和成员函数分开存储**：分别为每个对象的成员变量分配内存，但是所有对象都共享同一段函数代码。

> **成员变量在堆区或栈区分配内存，成员函数在代码区分配内存。**

##### 构造函数

名字和类名相同，没有返回值，不需要用户显式调用（用户也不能调用），而是在创建对象时自动执行。

> 构造函数往往用来做一些**初始化工作**，例如对成员变量赋值、预先打开文件等。
>
> 构造函数可以重载。
>
> 如果用户自己没有定义构造函数，那么编译器会自动生成一个默认的构造函数，只是这个构造函数的函数体是空的，也没有形参，也不执行任何操作。

> **析构函数没有参数，不能被重载**，因此一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。

初始化 const 成员变量只有一种方法，就是通过构造函数的初始化列表

##### 析构函数

> 创建对象时系统会自动调用构造函数进行初始化工作，同样，销毁对象时系统也会自动调用一个函数来进行清理工作，例如释放分配的内存、关闭打开的文件等，这个函数就是析构函数。
>
> 注意：**析构函数没有参数，不能被重载**，因此一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。
>
> **在堆区开辟的内存，在对象销毁要调用析构函数释放这块内存。**
>
> 如果对象内部在堆区申请了一个数组m_arr，那么默认的析构函数只会销毁对象本身，不会释放m_arr所指向的内存，因此需要自定义析构函数来释放这块内存。在自定义析构函数中，可以使用delete[]操作符来释放m_arr所指向的内存。
>
> ```c
> //构造函数在堆区开辟了一块内存存放数组
> VLA::VLA(int len): m_len(len){  //使用初始化列表来给 m_len 赋值
>  if(len > 0){ m_arr = new int[len];  /*分配内存*/ }
>  else{ m_arr = NULL; }
> }
> //对象销毁后堆区的这块内存并不会释放，所以需要析构函数去手动释放堆区内存
> VLA::~VLA(){
>  delete[] m_arr;  //释放内存
> }
> ```
>
> 注意：在使用自定义析构函数的同时，该类还有其他需要在销毁对象时进行资源释放的成员变量，也需要在析构函数中进行相应的释放操作。否则可能会导致内存泄漏等问题。
>
> **析构函数会在对象销毁时系统自动（隐示）调用**，程序员无法显示调用，也不能显示调用。
>
> 
>
> **析构函数执行时机**
>
> 析构函数在对象被销毁时调用，而对象的销毁时机与它所在的内存区域有关。
>
> 在所有函数之外创建的对象是**全局对象**（全局区），它和全局变量类似，位于内存分区中的全局数据区，程序在结束执行时会调用这些对象的析构函数。
>
> 在函数内部创建的对象是**局部对象**（栈区），它和局部变量类似，位于栈区，函数执行结束时会调用这些对象的析构函数。
>
>  **new 创建的对象位于堆区，通过 delete 删除时才会调用析构函数；如果没有 delete，析构函数就不会被执行。**

##### this指针

> 作用：**保证每个对象拥有自己的数据成员，共享处理这些数据成员的代码**
>

> this 是 const 指针，它的值是不能被修改的，一切企图修改该指针的操作，如赋值、递增、递减等都是不允许的。
>
> this 只能在成员函数内部使用，用在其他地方没有意义，也是非法的。
>
> 只有当对象被创建后 this 才有意义，因此**不能在 static 成员函数**中使用。

静态成员函数没有 this指针，不知道指向哪个对象。

编译器在编译一个普通成员函数时，会隐式地增加一个形参 this，并把当前对象的地址赋值给  this，所以普通成员函数只能在创建对象后通过对象来调用，**因为它需要当前对象的地址**。

##### 静态成员变量

> 使用静态成员变量来实现**多个对象共享数据**的目标。静态成员变量是一种特殊的成员变量，它被关键字`static`修饰。

static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 成员变量不能使用。

> static 成员变量和普通 static 变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。

static 成员变量**必须在类声明的外部初始化**，具体形式为：

```c++
type class::name = value;
```

##### 静态成员函数

> 普通成员函数可以访问所有成员（包括成员变量和成员函数），静态成员函数只能访问静态成员。

编译器在编译一个普通成员函数时，会隐式地增加一个形参 this，并把当前对象的地址赋值给  this，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。而静态成员函数可以通过类来直接调用，编译器不会为它增加形参  this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。

##### const成员函数

> 函数开头的 const 用来修饰函数的返回值，表示返回值是 const 类型，也就是不能被修改，例如`const char * getname()`。
>
> 函数头部的结尾加上 const 表示常成员函数，这种函数只能读取成员变量的值，而不能修改成员变量的值，例如`char * getname() const`。

##### const对象

在 [C++](http://c.biancheng.net/cplus/) 中，const 也可以用来修饰对象，称为常对象。一旦将对象定义为常对象之后，就只能调用类的 const 成员（包括 const 成员变量和 const 成员函数）了。

##### 友元函数和友元类

> 在 [C++](http://c.biancheng.net/cplus/) 中，一个类中可以有 public、protected、private 三种属性的成员，**通过对象可以访问 public 成员**，只有本类中的函数可以访问本类的 private 成员。现在，我们来介绍一种例外情况——友元（friend）。借助友元（friend），可以**使得其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员**。

在当前类以外定义的、不属于当前类的函数也可以在类中声明，但要在前面加 friend 关键字，这样就构成了友元函数。友元函数可以是不属于任何类的非成员函数，也可以是其他类的成员函数。

> **友元函数可以访问当前类中的所有成员，包括 public、protected、private 属性的。**
>
> **友元函数不同于类的成员函数，在友元函数中不能直接访问类的成员，必须要借助对象。友元函数的形参是一个对象指针或对象引用。**

不仅可以将一个函数声明为一个类的“朋友”，还可以将整个类声明为另一个类的“朋友”，这就是友元类。友元类中的所有成员函数都是另外一个类的友元函数。

 例如将类 B 声明为类 A 的友元类，那么类 B 中的所有成员函数都是类 A 的友元函数，可以访问类 A 的所有成员，包括 public、protected、private 属性的。

##### 多态和虚函数

> **通过基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数。**
>
> 为了让基类指针能够访问派生类的成员函数，C++增加了**虚函数（Virtual Function）**。使用虚函数非常简单，只需要在函数声明前面增加 virtual 关键字。

> 有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为**多态（Polymorphism）**。

**构成多态的条件**

> - 必须存在继承关系；
> - 继承关系中必须有同名的虚函数，并且它们是覆盖关系（函数原型相同）。
> - 存在基类的指针，通过该指针调用虚函数。

##### C++ `class`和`struct`到底有什么区别

在C语言中，`struct` 只能包含成员变量，不能包含成员函数。而在C++中，`struct` 类似于 `class`，既可以包含成员变量，又可以包含成员函数。

C++ `class`和`struct`区别：

> 使用 class 时，类中的成员默认都是 private 属性的；而使用 `struct` 时，结构体中的成员默认都是 public 属性的。
>
> class 继承默认是 private 继承，而 `struct` 继承默认是 public 继承。
>
> class 可以使用模板，而 `struct` 不能。



#### 继承和派生

> **继承（Inheri[tan](http://c.biancheng.net/ref/tan.html)ce）**可以理解为一个类从另一个类获取成员变量和成员函数的过程。

##### 三种继承方式

public、protected、private 三个关键字除了可以修饰类的成员，还可以指定继承方式。

> **1) public继承方式**
>
> - 基类中所有 public 成员在派生类中为 public 属性；
> - 基类中所有 protected 成员在派生类中为 protected 属性；
> - 基类中所有 private 成员在派生类中不能使用。
>
> 
> **2) protected继承方式**
>
> - 基类中的所有 public 成员在派生类中为 protected 属性；
> - 基类中的所有 protected 成员在派生类中为 protected 属性；
> - 基类中的所有 private 成员在派生类中不能使用。
>
> 
> **3) private继承方式**
>
> - 基类中的所有 public 成员在派生类中均为 private 属性；
> - 基类中的所有 protected 成员在派生类中均为 private 属性；
> - 基类中的所有 private 成员在派生类中不能使用。

继承时名字遮蔽问题：

> 基类成员和派生类成员的名字一样时会造成遮蔽，基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样。

##### 基类和派生类的构造函数

基类的成员函数可以被继承，可以通过派生类的对象访问，但这仅仅指的是普通的成员函数，**类的构造函数不能被继承**。构造函数不能被继承是有道理的，因为即使继承了，它的名字和派生类的名字也不一样，不能成为派生类的构造函数，当然更不能成为普通的成员函数。

> 在设计派生类时，对继承过来的成员变量的初始化工作也要由派生类的构造函数完成，但是大部分基类都有 private 属性的成员变量，它们在派生类中无法访问，更不能使用派生类的构造函数来初始化。
>
>  这种矛盾在[C++](http://c.biancheng.net/cplus/)继承中是普遍存在的，解决这个问题的思路是：**在派生类的构造函数中调用基类的构造函数。**
>
> 派生类构造函数总是先调用基类构造函数再执行其他代码。

> 基类构造函数不会被继承，不能当做普通的成员函数来调用。换句话说，**只能将基类构造函数的调用放在函数头部，不能放在函数体中**。下面代码是错误的：
>
> ```c++
> Student::Student(char *name, int age, float score){    
>     People(name, age);    
>     m_score = score;
> }
> ```
>
> 这样是正确的：
>
> ```c++
> Student::Student(char *name, int age, float score): m_score(score), People(name, age){ }
> ```
>
> **派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。**

基类构造函数调用规则：

事实上，通过派生类创建对象时必须要调用基类的构造函数，这是语法规定。换句话说，定义派生类构造函数时最好指明基类构造函数；如果不指明，就调用基类的默认构造函数（不带参数的构造函数）；如果没有默认构造函数，那么编译失败。

##### 基类和派生类的析构函数

> 另外析构函数的执行顺序和构造函数的执行顺序也刚好相反：
>
> - 创建派生类对象时，构造函数的执行顺序和继承顺序相同，即先执行基类构造函数，再执行派生类构造函数。
> - 而销毁派生类对象时，析构函数的执行顺序和继承顺序相反，即先执行派生类析构函数，再执行基类析构函数。

##### 作用域

> 全局作用域
>
> 局部作用域
>
> 块作用域：块作用域是指在代码块内部定义的变量只在该代码块内部可见和访问。代码块可以是由花括号{}括起来的任何一段代码。
>
> 类作用域
>
> 命名空间作用域

##### 继承时的对象内存模型

> 没有继承时对象内存，成员变量和成员函数会分开存储：
>
> - 对象的内存中只包含成员变量，存储在栈区或堆区（使用 new 创建对象）；
> - 成员函数与对象内存分离，存储在代码区。

> 有继承关系时，派生类的内存模型可以看成是基类成员变量和新增成员变量的总和，而所有成员函数仍然存储在另外一个区域——代码区，由所有对象共享。



#### 面向对象进阶

##### 引用

> **参数的传递本质上是一次赋值的过程**，赋值就是对内存进行拷贝。所谓内存拷贝，是指将一块内存上的数据复制到另一块内存上。

> 引用必须在定义的同时初始化，并且以后也要从一而终，不能再引用其它数据。
>
> 引用在定义时需要添加`&`，在使用时不能添加`&`，使用时添加`&`表示取地址。
>
> 通过引用也可以修改原始变量中所存储的数据，如果不希望通过引用来修改原始的数据，可以在定义时添加 `const` 限制。

**引用的本质**

> 引用只是对指针进行了简单的封装，它的底层依然是通过指针实现的，引用占用的内存和指针占用的内存长度一样，在 32 位环境下是 4 个字节，在 64 位环境下是 8 个字节，之所以不能获取引用的地址，是因为编译器进行了内部转换。
>
> ```c++
> int a = 99;
> int &r = a;
> r = 18;
> cout<<&r<<endl;
> ```
>
> 编译时会被转换成如下的形式：
>
> ```c++
> int a = 99;
> int *r = &a;
> *r = 18;
> cout<<r<<endl;
> ```
>
> 使用`&r`取地址时，编译器会对代码进行隐式的转换，使得代码输出的是 r 的内容（a 的地址），而不是 r 的地址，这就是为什么获取不到引用变量的地址的原因。也就是说，不是变量 r 不占用内存，而是编译器不让获取它的地址。

> 引用和指针在本质上是一样的，引用仅仅是对指针进行了简单的封装。**引用和指针都不能绑定到无法寻址的临时数据**。

> `const` 引用和普通引用不一样，我们只能通过 `const` 引用读取数据的值，而不能修改它的值。

##### 拷贝构造函数

> 当以拷贝的方式初始化一个对象时，会调用一个特殊的构造函数，就是拷贝构造函数。
>
> 拷贝构造函数只有一个参数，它的类型是当前类的引用，而且一般都是 `const` 引用。

> ###### 1) 为什么必须是当前类的引用呢？
>
> 如果拷贝构造函数的参数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将另外一个对象直接传递给形参，这本身就是一次拷贝，会再次调用拷贝构造函数，然后又将一个对象直接传递给了形参，将继续调用拷贝构造函数……这个过程会一直持续下去，没有尽头，陷入死循环。
>
> 只有当参数是当前类的引用时，才不会导致再次调用拷贝构造函数，这不仅是逻辑上的要求，也是 C++ 语法的要求。
>
> ###### 2) 为什么是 `const` 引用呢？
>
> 拷贝构造函数的目的是用其它对象的数据来初始化当前对象，并没有期望更改其它对象的数据，添加 `const` 限制后，这个含义更加明确了。
>
> 另外一个原因是，添加 `const` 限制后，可以将 `const` 对象和非 `const` 对象传递给形参了，因为非 `const` 类型可以转换为 `const` 类型。如果没有`const` 限制，就不能将 `const` 对象传递给形参，因为 `const` 类型不能转换为非 `const` 类型，这就意味着，不能使用 `const` 对象来初始化当前对象了。
>
> **3）什么时候调用拷贝构造函数**
>
> 初始化对象时会调用构造函数，不同的初始化方式会调用不同的构造函数：
>
> - 如果用传递进来的实参初始化对象，那么会调用**普通的构造函数**，我们不妨将此称为普通初始化；
> - 如果**用其它对象（现有对象）的数据来初始化对象，那么会调用拷贝构造函数**，这就是以拷贝的方式初始化。

##### 深拷贝

浅拷贝：简单的赋值拷贝操作

深拷贝：在堆区重新申请一块空间进行拷贝操作

如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题，导致程序崩溃

```c++
class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int age ,int height) {
		
		cout << "有参构造函数!" << endl;

		m_age = age;
		m_height = new int(height);
		
	}
	//拷贝构造函数  
	Person(const Person& p) {
		cout << "拷贝构造函数!" << endl;
		//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题
		m_age = p.m_age;
		m_height = new int(*p.m_height);
		
	}

	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
		if (m_height != NULL)
		{
			delete m_height;
		}
	}
public:
	int m_age;
	int* m_height;
};

void test01()
{
	Person p1(18, 180);

	Person p2(p1);

	cout << "p1的年龄： " << p1.m_age << " 身高： " << *p1.m_height << endl;

	cout << "p2的年龄： " << p2.m_age << " 身高： " << *p2.m_height << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

