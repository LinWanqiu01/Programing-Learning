### C/C++



#### 01 关键字

##### 1）**C语言宏中"#“和”##"的用法**

（#）字符串化操作符

> 作用：将宏定义中的传入参数名转换成用一对双引号括起来参数名字符串。其只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。

```c
#define example( instr )  printf( "the input string is:\t%s\n", #instr )
#define example1( instr )  #instr当使用该宏定义时：

example( abc ); // 在编译时将会展开成：printf("the input string is:\t%s\n","abc")
string str = example1( abc );  // 将会展成：string str="abc"
```

（##）符号连接操作符

> 作用：将宏定义的多个形参转换成一个实际参数名。

```c
#define exampleNum( n )  num##n

int num9 = 9;
int num = exampleNum( 9 ); // 将会扩展成 int num = num9
```

##### 2)**关键字volatile有什么含意？并举出三个不同的例子？**

> "volatile"是一种C和C++编程语言中的**存储类限定符**，用于告诉编译器不要对这个变量进行优化。当一个变量被声明为volatile时，意味着该变量可能随时发生变化，而编译器不应该假设该变量的值不会改变。实际上，当我们使用volatile修饰的变量时，其实就是在告诉编译器，它需要将这个变量对应的内存地址作为数据操作的目标地址，而**不是将这个变量值读入寄存器中**，并对寄存器进行操作。

> 以下是三个使用volatile的例子：
>
> 1.**嵌入式系统中的外部硬件地址：**在编写嵌入式系统代码时，需要与外部硬件交互。这些硬件通常使用特定寄存器来控制或传输数据。在这种情况下，可以使用volatile关键字告诉编译器在访问这些寄存器时不要采取任何优化措施。否则，编译器可能会认为这些寄存器的值不会突然变化，从而导致错误。
>
> 2.**多线程环境下的共享变量：**在并发程序设计中，多个线程可能同时访问同一个变量。在这种情况下，如果变量没有被声明为volatile，则编译器可能会产生无法预测的结果。因为编译器会对代码进行优化，从而导致变量在缓存中的拷贝无法及时更新到内存中，从而造成读写不同步的问题。
>
> 3.**信号处理函数中使用的静态变量：**在信号处理函数中，不能够使用所有的变量类型，因为它们可能是不可重入的。在这种情况下，可以使用volatile声明一个静态变量，以确保编译器不会对其进行优化。这使得信号处理函数能够安全地访问该变量，而不会造成任何错误。

##### **3)关键字static的作用是什么？**

> 1.**静态局部变量：**当一个局部变量被声明为`static`时，在程序首次执行到该变量的定义处时会被初始化，多次调用时只初始化一次。每次调用static局部变量不会被再次初始化，而是会保持上次调用之后的值，因为static局部变量存储于程序内存的数据区。
>
> 2.**静态全局变量：**当一个全局变量被声明为`static`时，它在整个程序运行期间都是存在的，但是它的可见性仅限于当前文件。因此，其他文件无法访问此变量，这样可以有效地避免命名冲突。
>
> 3.**静态函数：**当一个函数被声明为`static`时，它的作用域仅限于当前文件。其他文件无法引用该函数。因此，在将函数声明为`static`后，可以使得函数不被其他文件覆盖，也能够提高程序的安全性。
>
> 4.**静态成员变量：**当在一个类中声明一个变量为static时，该变量将为该类的所有对象所共享，无论创建多少个该类的对象，都只分配一个static数据成员。静态成员变量既可以通过对象名访问，也可以通过类名访问。必须在类外初始化。
>
> 私有的成员变量，不能通过对象直接访问，必须借助public 属性的成员函数来修改它们的值。
>
> 5.**静态成员函数：**普通成员函数可以访问所有成员（包括成员变量和成员函数），静态成员函数只能访问静态成员。**当静态成员变量权限为private时，类外访问private静态成员变量就需要调用public的静态成员函数。**

##### 4）**为什么 static变量只初始化一次**？

> static变量初始化后，一直都没有被销毁，**都会保存在程序内存的数据区中**，所以不会再次初始化。而普通局部变量存放在程序内存的栈区，在函数每次执行完后会自动销毁，所以需要每次初始化。

##### 5）**extern”C” 的作用是什么？**

> "extern C" 是一个 C++ 的语言特性，用于指定特定代码应该按照 C 语言的方式进行编译和链接。
>
> extern "C" 的作用是将 C++ 代码同 C 语言的命名和符号规则进行匹配，从而实现 C++ 和 C 语言之间的兼容和互操作。

##### 6）const有什么作用？

> const关键字可以使该变量成为只读的常量，无法被修改。
>
> const关键字可以帮助程序员避免在代码使用过程中发生意外的数据改变，提高程序的稳定性和安全性。

修饰常指针:

```c
const int *p； //指向常量的指针，p值可以变，p指向的数值内容不可变
int const *p； //常量指针 p指向的内存不可以变，但是p指向的数值可以变
int* const p；//同2
const int* const p；//指向常量的常量指针。即p指向的内存和数值都不可变
```

##### 7)**new/delete与malloc/free的区别是什么？**

> 1.new、delete是C++中的**标准运算符**，而malloc和free是**标准库函数**。
>
> 2.都可以完成动态内存分配，**new返回的是指定类型的指针**，并且可以自动计算所申请内存的大小。而 malloc需要我们计算申请内存的大小，并且在返回时强行转换为实际类型的指针。
>
> 3.对于**非内部数据对象**来说，只使用malloc是无法完成动态对象要求的，一般在创建对象时需要调用构造函数，对象消亡时，自动的调用析构函数。而malloc 和free是库函数而不是运算符，不在编译器控制范围之内，不能够自动调用构造函数和析构函数。而new在为对象申请分配内存空间时，可以自动调用构造函数，同时也可以完成对对象的初始化。同理，delete也可以自动调用析构函数。而mallloc只是做一件事，只是为变量分配了内存，同理，free也只是释放变量的内存。

##### 8)**左值和右值是什么？**

> 左值是指可以出现在等号左边的变量或表达式，它最重要的特点就是**可写**（可寻址）。也就是说，它的值**可以被修改**，如果一个**变量或表达式的值不能被修改**，那么它就不能作为左值。
>
> 右值是指**只可以出现在等号右边的变量或表达式**。它最重要的特点是**可读**。一般的使用场景都是把一个右值赋值给一个左值。
>
> 通常，左值可以作为右值，但是右值不一定是左值。

##### 9)**++a和a++有什么区别？两者是如何实现的？**

a++的具体运算过程为

```c
int temp = a;
a=a+1;
return temp;
```

++a的具体运算过程为

```c
a=a+1;
return a;
```

后置自增运算符需要把原来变量的值复制到一个**临时的存储空间**，等运算结束后才会返回这个临时变量的值。所以前置自增运算符效率比后置自增要高.



#### 02 内存

##### 1）堆与栈有什么区别？

> **1.申请方式：**栈的空间由操作系统自动分配/释放，堆上的空间手动分配/释放。
>
> **2.空间大小不同：** 栈空间有限，在Windows下,栈是向**低地址**扩展的数据结构，是一块**连续的内存的区域**。
>
> 堆是向**高地址**扩展的数据结构，是不连续的内存区域。这是由于系统是用**链表来存储的空闲内存地址的**，自然是不连续的，而链表的遍历方向是由低地址向高地址。**堆的大小受限于计算机系统中有效的虚拟内存。**
>
> **3.申请效率：**栈由系统自动分配，速度较快。但程序员是无法控制的。
> 堆是通过运算符new或库函数malloc分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便；
>
> **4.扩展方向不同：**堆从低地址向高地址扩展，栈从高地址向低地址扩展。

##### 2）**C语言函数参数压栈顺序是怎样的？**

> 从右到左

##### 3）C++如何处理返回值？

> 1.传递值：通过将结果存储在变量中，并通过return语句返回该值来实现。
>
> 2.传递指针：通过返回指向分配在堆上的数据的指针来返回结果。
>
> ```c++
> int* getValues(int num) {
>     int* values = new int[num];
>     for (int i = 0; i < num; ++i) {
>         values[i] = i + 1;
>     }
>     return values;
> }
> 
> ```
>
> 3.传递引用:将结果存储在传递给函数的引用数据类型中。因此，在这种情况下，函数不需要返回任何东西。
>
> ```c++
> void swap(int& a, int& b) {
>     int temp = a;
>     a = b;
>     b = temp;
> }
> ```

##### 4）深拷贝和浅拷贝

浅拷贝：简单的赋值拷贝操作

深拷贝：在堆区重新申请一块空间进行拷贝操作

如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题

##### 5）拷贝构造函数和拷贝赋值函数



##### 6）**什么是内存泄漏？**

在堆区申请了一块内存空间，使用完毕后没有释放掉。

由程序申请的一块内存，且没有任何一个指针指向它，那么这块内存就泄露了。

##### 7）内存溢出和内存越界

> 内存溢出(Memory Overflow):
>
> **是指程序试图访问超出已分配内存范围的内存位置,这可能会覆盖其他变量的值。**
>
> 例如:
>
> - 向数组中写入元素个数超过数组定义的大小
> - 向指针指向的内存区域写入数据超过其可用大小
> - 递归调用深度超过栈大小限制
>
> 内存溢出可能导致程序崩溃,或产生难以追踪的bug。

> 内存越界(Memory Out of Bounds):
>
> **是指程序试图访问数组或其他数据结构中的一个元素,但其下标超出了数组或结构的有效范围。**
>
> 例如:
>
> - 使用负数下标访问数组
> - 使用大于数组大小的下标访问数组
> - 访问链表中的一个不存在的节点

#### 03 指针

##### 1）**数组指针和指针数组有什么区别？**

> 数组指针就是指向数组的指针，它表示的是一个指针，这个指针指向的是一个数组。
>
> 指针数组表示的是一个数组，而数组中的元素是指针。
>
> int *p[4]：被定义为一个指向整数类型指针的数组，该数组有4个元素。
>
> ```c++
> int a = 10, b = 20, c = 30, d = 40;
> int *p[4] = {&a, &b, &c, &d};
> ```
>
> int (*p)[4]:]被定义为一个指针，它指向一个长度为4的整数数组。也就是说，该指针可以存储指向整型数组的地址。（二维数组指针）
>
> ```c++
> int arr[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};
> int (*p)[4] = arr; 
> //**(++arr)对应的值为5
> ```

##### 2）**函数指针和指针函数有什么区别？**

> 1.函数指针
>
> 如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个**函数的地址**。而且函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称**函数指针**。
>
> **需要注意的是，指向函数的指针变量没有 ++ 和 -- 运算。**
>
> ```c++
> int add(int x, int y) { return x + y; }
> int sub(int x, int y) { return x - y; }
> 
> int main() {
>   int (*fp)(int, int);
>   fp = add;
>   int res = fp(1, 2);
>   fp = sub;
>   res = fp(1, 2);
> }
> ```
>
> 2.指针函数
>
> 指针函数是一种返回指针类型的函数，可以将其看作返回值是指针的一个普通函数。
>
> ```c++
> char* getFirstChar(const char* str) {
>   return str;
> }
> 
> int main() {
>   char s[] = "Hello World";
>   char* p = getFirstChar(s);
>   printf("%c", *p);   // 输出'H'
> }
> ```

##### 3）**数组名和指针的区别与联系是什么？**

> 指针本身在内存中占用的空间大小是与操作系统的位数相关的，在32位操作系统中，一个指针通常占用4个字节（32位），而在64位操作系统中，一个指针通常占用8个字节（64位）。
>
> **1.数据保存方面**
>
> 指针保存的是地址（保存目标数据地址，自身地址由编译器分配），内存访问偏移量为4或8个字节，无论其中保存的是何种数据均已地址类型进行解析。
>
> 数组保存的数据。数组名表示的是第一个元素的地址，内存访问偏移量是保存数据类型的内存偏移量。
>
> **2.数据访问方面**
>
> 指针对数据的访问方式是间接访问，需要用到解引用符号（*数组名）。
>
> 数组对数据的访问则是直接访问，可通过下标访问或数组名+元素偏移量的方式

##### 4）**常量指针，指向常量的指针，指向常量的常量指针有什么区别？**

> 1.常量指针
>
> ```c
> int * const p
> ```
>
> **不能修改这个指针的指向**，但是这个指针所指向的地址上存储的**值可以修改**。
>
> 2.指向常量的指针
>
> ```c
> const int *p
> ```
>
> 不能通过指针来修改这个指针**指向的值**，指针的指向可以修改，但是不能修改这个指针指向的数据的值。
>
> 3.指向常量的常量指针
>
> ```c
> const int *const p
> ```
>
> 指针指向和指针指向的地址上存储的值都不可以修改。

##### 5）引用和指针的区别

> 1.引用的本质在c++内部实现是一个**指针常量**，指向不能变，但指向地址上的值可以变。
>
> 2.引用必须在定义时初始化，并且以后也要从一而终，不能再指向其他数据；而指针没有这个限制，指针在定义时不必赋值，以后也能指向任意数据。
>
> 3.可以有 const 指针，但是没有 const 引用。
>
> 4.指针可以有多级，但是引用只能有一级。
>
> 5.指针和引用的自增（++）自减（--）运算意义不一样。对指针使用 ++ 表示指向下一份数据，对引用使用 ++ 表示它所指代的数据本身加 1；自减（--）也是类似的道理。

##### 6) **野指针是什么？**

> 1.野指针是指向不可用内存的指针，当指针被创建时，指针不可能自动指向NULL，这时，默认值是随机的，此时的指针成为野指针。
>
> 2.指针指向的对象被删除后，没有将指针赋值为 NULL 或者其他合法的地址。
>
> 3.第三个造成野指针的原因是指针操作超越了变量的作用范围。

##### 7）**如何避免野指针？**

> 1.对指针进行初始化；
>
> 2.指针用完后释放内存，将指针赋NULL；
>
> ```c
> delete(p);
> p = NULL;
> ```

##### 8)空指针

> 空指针是指一个指向空地址的指针，它不指向任何实际的内存单元。在 C++ 中，可以用 `nullptr` 或者 NULL（在老版本中使用）关键字来表示一个空指针。

##### 9）void*

> `void *` 是C++中的一种特殊指针类型，它可以指向任意类型的对象或数据，包括函数、对象、内存块等。其关键字 `void` 表示无类型，因此 `void *` 是一个通用的指针类型，不关注所指向内存区域的类型，可以用于处理多种数据类型。

##### 10)引用和指针的区别

> 引用必须在定义时初始化，并且以后也要从一而终，不能再指向其他数据；而指针没有这个限制，指针在定义时不必赋值，以后也能指向任意数据。
>
> 可以有 const 指针，但是没有 const 引用。也就是说，引用变量不能定义为下面的形式：
>
> ```c++
> int a = 20;
> int & const r = a;//因为 r 本来就不能改变指向，加上 const 是多此一举。
> ```
>
> 指针可以有多级，但是引用只能有一级。
>
>  指针和引用的自增（++）自减（--）运算意义不一样。

#### 04 变量

##### 1）全局变量和静态全局变量的区别

> 作用域不同：全局变量的作用域是整个程序，静态全局变量的作用域是当前源文件。

##### 2）全局变量和局部变量

> 1.作用域不同：全局变量的作用域是整个程序；局部变量的作用域是当前函数。
>
> 2.存储方式不同：全局变量存储在代码内存的数据区；局部变量存储在内存的栈区。
>
> 3.生命周期不同：全局变量的生命周期是整个程序运行过程；位于栈中的局部变量在函数调用结束后销毁。

##### 3）局部变量和静态局部变量

> 1.存储方式不同
>
> 2.生命周期不同

##### 4）**局部变量能否和全局变量重名？**

> 局部变量可以和全局变量重名，局部变量会屏蔽全局变量。
>
> 局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。

#### 05 函数

##### 1）**请写个函数在main函数执行前先运行**

> `__attribute__`可以设置函数属性（Function Attribute）、变量属性（Variable Attribute）和类型属性（Type Attribute）。
>
> gnu对于函数属性主要设置的关键字如下：
>
> ```c++
>  alias:      
> 	 设置函数别名。
>  aligned:    
> 	 设置函数对齐方式。
>  always_inline/gnu_inline: 
>      函数是否是内联函数。
>  constructor/destructor:
>      主函数执行之前、之后执行的函数。
>  format:
>      指定变参函数的格式输入字符串所在函数位置以及对应格式输出的位置。
>  noreturn:
>      指定这个函数没有返回值。
>      请注意，这里的没有返回值，并不是返回值是void。而是像_exit/exit/abord那样
>      执行完函数之后进程就结束的函数。
>  weak：
>      指定函数属性为弱属性，而不是全局属性，一旦全局函数名称和指定的函数名称命名有冲突，使用全局函数名称。
> ```
>
> 示例代码如下：
>
> ```c
> #include <stdio.h>
> 
> void before() __attribute__((constructor));
> void after() __attribute__((destructor));
> 
> void before() {
>     printf("this is function %s\n",__func__);
>     return;
> }
> 
> void after(){
>     printf("this is function %s\n",__func__);
>     return;
> }
> 
> int main(){
>     printf("this is function %s\n",__func__);
>     return 0;
> }
> 
> // 输出结果
> // this is function before
> // this is function main
> // this is function after
> ```

##### 2)**为什么析构函数必须是虚函数？**

> 将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，**释放基类指针时可以释放掉子类的空间，防止内存泄漏。**

##### 3）全局函数和静态成员函数区别？



##### 4）**为什么C++默认的析构函数不是虚函数？**

> C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。

##### 5）**C++中析构函数的作用？**

> 1. 在对象被销毁时关闭打开的文件或数据库连接等资源。
> 2. 释放对象占用的内存空间，以避免内存泄漏。
> 3. 清除与对象相关的临时文件或日志等数据。

##### 6）静态成员函数和虚函数的区别

> 1.静态成员函数只能访问静态成员变量，虚函数可以访问所有成员。
>
> 2.静态函数的调用在编译期就已经决定，无法在运行时动态改变，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销。

##### 7）lambda函数

> Lambda函数（也称为匿名函数或闭包）是一种**可以在函数内部定义函数的特殊语法结构**，它可以像函数一样被调用，可以在需要的地方直接定义和使用，**不需要像普通函数那样需要先定义再调用**。
> Lambda函数的一般语法形式如下：
>
> ```c++
> [capture-list](params-list)->return-type{function-body}
> ```
> 其中，capture-list（捕获列表）用于指定Lambda函数中需要访问的外部变量，并指定它们的访问方式；params-list（参数列表）用于指定Lambda函数的参数列表；return-type（返回类型）用于指定Lambda函数的返回类型；function-body（函数体）用于指定Lambda函数的实现代码。
> 例如，下面是一个简单的Lambda函数的例子：
> ```c++
> auto add = [](int a, int b) { return a + b; };
> int result = add(1, 2);
> ```
> 这个Lambda函数以数值的方式捕获外部变量，接受两个整数型参数a和b，并返回它们的和。在调用函数时，可以像普通函数一样直接调用，例如add(1, 2)就会返回3。
> Lambda函数的返回值类型可以自动推导，也可以显式指定。
>
> 捕获方式：
>
> ```c++
> #include<iostream>  
> using namespace std;
> int main() {
> int a=9;
> auto fun1=[=]{return ++a;};//代码片段1
> auto fun2=[&]{return ++a;};//代码片段2
> auto fun2=[=]()mutable{return ++a;};//代码片段3 
> return 0;
> }
> ```
>
> 这段代码中定义了三个lambda函数，分别是fun1、fun2和fun3。它们都访问了变量a，但是它们的捕获方式不同，因此对变量a的修改也不同。
> 代码片段1中，使用了**=捕获方式**，**表示以值的方式捕获所有外部变量**，因此a的值在lambda函数中是**只读的，无法被修改**。lambda函数fun1返回a的值加1，但不会改变变量a的值。
> 代码片段2中，使用了**&捕获方式，表示以引用的方式捕获所有外部变量**，因此lambda函数fun2**可以修改变量a的值**。lambda函数fun2返回a的值加1，并且会将变量a的值加1。
> 代码片段3中，使用了**mutable关键字，表示在lambda函数中可以修改被捕获的变量**。由于同时使用了=和mutable，表示以值的方式捕获所有外部变量，并且可以在lambda函数中修改它们的值。lambda函数fun3返回a的值加1，并且会将变量a的值加1。
> 需要注意的是，这三个lambda函数的返回值类型都是自动推导的，实际上它们的返回值类型都是int。因为它们返回的是变量a的值加1，而变量a的类型是int。如果要返回其他类型的值，可以在lambda函数后面指定返回类型，例如：
>
> ```c++
> auto fun4=[]()->double{return 3.14;};
> ```
> 这个lambda函数的返回值类型是double，返回值是3.14。

##### 8) memset()、memcpy()

> **memset()和memcpy()都是C++语言中的库函数，用于对内存进行赋值和复制。**
> memset()函数的作用是将指定的内存区域按字节进行初始化，即将指定长度的内存空间以指定的值填充。其函数原型为：
>
> ```c++
> void *memset(void *s, int c, size_t n);
> ```
> 其中，s是指向待填充内存区域的指针，c是待填充的值，n是指定长度。函数返回指向s的指针。
> 例如，以下代码将一个长度为5的整型数组nums初始化为0：
> ```c++
> int nums[5];
> memset(nums, 0, sizeof(nums));
> ```
> memcpy()函数的作用是将一个内存区域的内容复制到另一个内存区域，其函数原型为：
> ```c++
> void *memcpy(void *dest, const void *src, size_t n);
> ```
> 其中，dest是指向目标内存区域的指针，src是指向源内存区域的指针，n是需要复制的字节数。函数返回指向dest的指针。
> 例如，以下代码将一个长度为5的整型数组nums1复制到另一个数组nums2中：
> ```c++
> int nums1[5] = {1, 2, 3, 4, 5};
> int nums2[5];
> memcpy(nums2, nums1, sizeof(nums1));
> ```
> 这样，数组nums2中的元素就和数组nums1中的元素相同了。需要注意的是，如果源内存区域和目标内存区域发生重叠，那么结果是未定义的。因此，在进行**内存复制时需要保证源内存区域和目标内存区域不存在重叠。**
>
> **注意：类实例不能使用memcpy和memset进行拷贝和赋值。**

##### 9）函数重载

> **函数的重载的规则：**
>
> 函数名称必须相同。
>
> 参数列表必须不同（个数不同、类型不同、参数排列顺序不同等）。
>
> 函数的返回类型可以相同也可以不相同。
>
> 仅仅返回类型不同不足以成为函数的重载。

##### 10）C++ 是如何做到函数重载的

C++代码在编译时会根据参数列表对函数进行重命名，例如`void Swap(int a, int b)`会被重命名为`_Swap_int_int`，`void Swap(float x, float y)`会被重命名为`_Swap_float_float`。当发生函数调用时，编译器会根据传入的实参去逐个匹配，以选择对应的函数，如果匹配失败，编译器就会报错，这叫做重载决议（Overload Resolution）。

> 不同的编译器有不同的重命名方式，这里仅仅举例说明，实际情况可能并非如此。

从这个角度讲，函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。

















