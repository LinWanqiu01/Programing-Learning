#### 1  基本概念

> 信号是事件发生时对进程的通知机制，也可以把它称为软件中断。信号与硬件中断的相似之处在于能够 打断程序当前执行的正常流程，其实是在软件层次上对中断机制的一种模拟。大多数情况下，是无法预测信 号达到的准确时间，所以，信号提供了一种处理异步事件的方法。

##### 1.1  信号的目的是用来通信的

一个具有合适权限的进程能够向另一个进程发送信号，信号的这一用法可作为一种同步技术，甚至是进 程间通信（IPC）的原始形式。

**线程同步中的条件变量方式即使用信号的方式解决线程之间的资源竞争。**

> 用于在终端下输入了能够产生信号的特殊字符。譬如在终端上按下 CTRL + C 组合按键可以产生中 断信号（SIGINT），通过这个方法可以终止在前台运行的进程；按下 CTRL + Z 组合按键可以产生 暂停信号（SIGCONT），通过这个方法可以暂停当前前台运行的进程。

> 用户可以通过 kill 命令将信号发送给其它进程。kill 命令想必大家都会使用，通常我们会通过 kill 命令来“杀死”（终止）一个进程，譬如在终端下执行"kill -9 xxx"来杀死 PID 为 xxx 的进程。kill 命令其内部的实现原理便是通过 kill()系统调用来完成的。

进程同样也可以向自身发送信号，然而发送给进程的诸多信号中，大多数都是来自于内核。

信号的目的都是用于通信的，当发生某种情况 下，通过信号将情况“告知”相应的进程，从而达到同步、通信的目的。

##### 1.2  信号由谁处理、怎么处理

信号通常是发送给对应的进程，当信号到达后，该进程需要做出相应的处理措施，通常进程会视具体信 号执行以下操作之一：

> **忽略信号。**也就是说，当信号到达进程后，该进程并不会去理会它、直接忽略，就好像是没有出该 信号，信号对该进程不会产生任何影响。事实上，大多数信号都可以使用这种方式进行处理。

> **捕获信号。**当信号到达进程后，执行预先绑定好的信号处理函数。为了做到这一点，要通知内核在 某种信号发生时，执行用户自定义的处理函数，该处理函数中将会对该信号事件作出相应的处理， **Linux 系统提供了 signal()系统调用可用于注册信号的处理函数**。

> **执行系统默认操作。**进程不对该信号事件作出处理，而是交由系统进行处理，每一种信号都会有其 对应的系统默认的处理方式。需要注意的是，对大多数信号来说，系 统默认的处理方式就是终止该进程。

在多线程编程中，可以通过`int pthread_cancel(pthread_t thread);`在一个线程终止另一个线程。如果不设置目标线程（即要终止线程）的属性，目标线程并不会在收到cancel信号后立即终止，而是等到一个“可取消点”才终止。

##### 1.3  信号是异步的

> 信号是异步事件，产生信号的事件对进程而言是随机出现的，进程无法预测该事件产生的准 确时间。就如同硬件 中断事件，程序是无法得知中断事件产生的具体时间，只有当产生中断事件时，才会告知程序、然后打断当 前程序的正常执行流程、跳转去执行中断服务函数，这就是**异步处理方式**。

##### 1.4  信号本质上是 int 类型数字编号

> 信号本质上是 int 类型的数字编号，这就好比硬件中断所对应的中断号。内核针对每个信号，都给其定 义了一个唯一的整数编号，从数字 1 开始顺序展开。并且每一个信号都有其对应的名字（其实就是一个宏）， 信号名字与信号编号乃是一一对应关系，但是由于每个信号的实际编号随着系统的不同可能会不一样，所 以在程序当中一般都使用信号的符号名（也就是宏定义）。
>
> 这些信号在头文件中定义，每个信号都是以 SIGxxx 开头。

#### 2  常见信号与默认行为

##### 2.1  SIGINT

> 当用户在终端按下中断字符（通常是 CTRL + C）时，内核将发送 SIGINT 信号给前台进程组中的每一 个进程。该信号的系统默认操作是**终止进程的运行**。所以通常我们都会使用 CTRL + C 来终止一个占用前台 的进程，原因在于大部分的进程会将该信号交给系统去处理，从而执行该信号的系统默认操作。

##### 2.2  SIGTERM

> 这是用于终止进程的标准信号，也是 kill 命令所发送的默认信号（kill xxx，xxx 表示进程 pid），有时 我们会直接使用"kill -9 xxx"显式向进程发送 SIGKILL 信号来终止进程，然而这一做法通常是错误的，精心 设计的应用程序应该会捕获 SIGTERM 信号、并为其绑定一个处理函数，当该进程收到 SIGTERM 信号时， 会在处理函数中清除临时文件以及释放其它资源，再而退出程序。如果直接使用 SIGKILL 信号终止进程， 从而跳过了 SIGTERM 信号的处理函数，通常 SIGKILL 终止进程是不友好的方式、是暴力的方式，这种方 式应该作为最后手段，应首先尝试使用 SIGTERM，实在不行再使用最后手段 SIGKILL。

#### 3  进程对信号的处理

当进程接收到内核或用户发送过来的信号之后，根据具体信号可以采取不同的处理方式：忽略信号、捕 获信号或者执行系统默认操作。**Linux 系统提供了系统调用 signal()和 sigaction()两个函数用于设置信号的处理方式。**

##### 3.1  signal()函数

signal()函数是 Linux 系统下设置信号处理方式最简单的接口，可将信号的 处理方式设置为捕获信号、忽略信号以及系统默认操作，此函数原型如下所示：

```c++
#include <signal.h>
typedef void (*sig_t)(int);
sig_t signal(int signum, sig_t handler);
```

> **signum：**此参数指定需要进行设置的信号，可使用信号名（宏）或信号的数字编号，建议使用信号名。
>
>  **handler：**sig_t 类型的函数指针，指向信号对应的信号处理函数，当进程接收到信号后会自动执行该处 理函数；参数 handler 既可以设置为用户自定义的函数，也就是捕获信号时需要执行的处理函数，也可以设 置为 SIG_IGN 或 SIG_DFL，SIG_IGN 表示此进程需要忽略该信号，SIG_DFL 则表示设置为系统默认操作。 sig_t 函数指针的 int 类型参数指的是，当前触发该函数的信号，可将多个信号绑定到同一个信号处理函数 上，此时就可通过此参数来判断当前触发的是哪个信号。

##### 3.2  sigaction()函数

除了signal()之外，sigaction()系统调用是设置信号处理方式的另一选择，推荐使用sigaction() 函数。虽然 signal()函数简单好用，而 sigaction()更为复杂，但作为回报，sigaction()也更具灵活性以及移植性。

#### 4  示例代码

```c++
#include <iostream>
#include <signal.h>
#include <unistd.h>

// 信号处理函数
void print(int sigmum){
    std::cout <<"finished" << std::endl;
    exit(0); // 结束进程
}

int main() {
    int i=0;
    signal(SIGINT, print);//系统调用
    signal(SIGTERM, print);

    for(;;) {
        std::cout << "running:" <<i<< std::endl;

        if(i==44){
            pid_t pid=getpid(); // 获取当前进程的PID
            std::cout<<"Current PID: "<<pid<<std::endl;
            kill(pid, SIGTERM); // 向当前进程发送SIGTERM信号，即终止本进程
        }

        i++;
        sleep(1); // 等待1秒钟
    }

    return 0;
}

```

